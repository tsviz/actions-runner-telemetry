name: Example CI with Telemetry

# This workflow demonstrates the telemetry action using simulated workloads.
# Copy this pattern and replace the simulation steps with your actual build commands.

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allow manual triggers for testing

env:
  # Set to 'false' to disable telemetry without modifying the workflow
  TELEMETRY_ENABLED: 'true'

jobs:
  build:
    name: Build & Test (Demo)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Start telemetry
      - name: Telemetry
        uses: tsviz/actions-runner-telemetry@v1
        with:
          enabled: ${{ env.TELEMETRY_ENABLED }}

      # Simulated workload steps (replace with your actual build commands)
      - name: '[Telemetry] Install Dependencies'
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: step
          step-name: "Install Dependencies"
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Simulate Install Dependencies
        run: |
          echo "ğŸ“¦ Simulating dependency installation..."
          # Create some CPU load
          for i in {1..3}; do
            echo "Installing package $i..."
            dd if=/dev/urandom bs=1M count=10 2>/dev/null | gzip > /dev/null
            sleep 1
          done
          echo "âœ… Dependencies installed"

      - name: '[Telemetry] Build'
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: step
          step-name: "Build"
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Simulate Build
        run: |
          echo "ğŸ”¨ Simulating build process..."
          # Create CPU + memory load
          python3 -c "
          import time
          data = []
          for i in range(5):
              data.append('x' * (1024 * 1024 * 10))  # 10MB chunks
              print(f'Building module {i+1}/5...')
              time.sleep(1)
          print('âœ… Build complete')
          "

      - name: '[Telemetry] Tests'
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: step
          step-name: "Tests"
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Simulate Tests
        run: |
          echo "ğŸ§ª Running tests..."
          # Parallel test simulation
          for i in {1..4}; do
            (dd if=/dev/urandom bs=512K count=5 2>/dev/null | gzip > /dev/null; echo "Test suite $i passed âœ“") &
          done
          wait
          echo "âœ… All tests passed"

      - name: '[Telemetry] Lint'
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: step
          step-name: "Lint"
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Simulate Lint
        run: |
          echo "ğŸ” Linting code..."
          sleep 2
          echo "âœ… No linting issues found"

      # Stop telemetry and generate report
      - name: Stop Telemetry
        if: always()
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: stop
          enabled: ${{ env.TELEMETRY_ENABLED }}

      # Upload telemetry artifacts (optional)
      - name: Upload Telemetry Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: telemetry-${{ github.run_id }}
          path: |
            telemetry-report.md
            telemetry-dashboard.html
            telemetry-raw.json
            telemetry-samples.csv
            telemetry-summary.json
          retention-days: 14
          if-no-files-found: ignore

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ALTERNATIVE: With per-step tracking for detailed analysis
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Note: Still just one start step - Docker action's post-entrypoint
  # automatically generates the report after all steps complete.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-with-steps:
    name: Build & Test (With Step Tracking)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Start telemetry
      - name: Start Telemetry
        uses: tsviz/actions-runner-telemetry@v1
        with:
          enabled: ${{ env.TELEMETRY_ENABLED }}

      # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      # â•‘  OPTIONAL STEP MARKERS - Track per-step resources             â•‘
      # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: '[Telemetry] Install Dependencies'
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: step
          step-name: "Install Dependencies"
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Install Dependencies
        run: |
          echo "ğŸ“¦ Installing dependencies..."
          for i in {1..3}; do
            dd if=/dev/urandom bs=1M count=5 2>/dev/null | gzip > /dev/null
            sleep 1
          done

      - name: '[Telemetry] Build'
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: step
          step-name: "Build"
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Build
        run: |
          echo "ğŸ”¨ Building..."
          python3 -c "
          import time
          for i in range(3):
              data = 'x' * (1024 * 1024 * 20)
              print(f'Compiling module {i+1}...')
              time.sleep(1)
          "

      - name: '[Telemetry] Test'
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: step
          step-name: "Test"
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Test
        run: |
          echo "ğŸ§ª Testing..."
          for i in {1..3}; do
            echo "Running test suite $i..."
            sleep 1
          done

      # Stop telemetry and generate report (required for per-step tracking)
      - name: Stop Telemetry
        if: always()
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: stop
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Upload Telemetry Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: telemetry-detailed-${{ github.run_id }}
          path: |
            telemetry-report.md
            telemetry-dashboard.html
          retention-days: 14
          if-no-files-found: ignore

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # QUICK CHECK: Snapshot mode for one-time capture
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  quick-check:
    name: Quick Resource Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run Some Work
        run: |
          echo "Running quick workload..."
          dd if=/dev/urandom bs=1M count=20 2>/dev/null | gzip > /dev/null
          sleep 2

      # Take a snapshot at this point in time
      - name: Resource Snapshot
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: snapshot
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Upload Snapshot
        uses: actions/upload-artifact@v4
        with:
          name: resource-snapshot
          path: telemetry-report.md
          if-no-files-found: ignore

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # OVERUTILIZED: Heavy workload that needs a larger runner
  # Report auto-generates via Docker action post-entrypoint
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  heavy-workload:
    name: Heavy Build (Over Utilized)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Start telemetry
      - name: Start Telemetry
        uses: tsviz/actions-runner-telemetry@v1
        with:
          enabled: ${{ env.TELEMETRY_ENABLED }}

      # âš ï¸  IMPORTANT: For accurate memory metrics, step markers must be placed
      # DURING the workload in the same process/container, not in separate "uses:" steps.
      # Each "uses:" step runs in a new Docker container, so memory is no longer visible.
      # Solution: Call mark_step() directly from Python while memory is allocated.
      - name: Heavy CPU & Memory Load
        run: |
          echo "âš ï¸  Running heavy workload with memory tracking..."
          
          python3 << 'PYTHON_EOF'
          import sys
          import os
          sys.path.insert(0, "/")
          from telemetry_collector import mark_step
          
          import time
          from multiprocessing import Pool
          
          # Mark baseline BEFORE heavy work
          print("ğŸ“ Marking baseline...")
          mark_step("Baseline")
          
          print("ğŸ“Š Starting heavy workload (CPU + Memory intensive)...")
          print(f"   CPU Count: {os.cpu_count()}")
          
          # Allocate memory arrays
          print("ğŸ’¾ Pre-allocating memory (1.5GB sustained)...")
          huge_arrays = []
          
          # Create 3 large arrays 
          for idx in range(3):
              # 500MB each = 1.5GB total (~10% of available 15GB)
              arr = list(range(125000000))  # 125M integers = ~500MB
              huge_arrays.append(arr)
              print(f"   Array {idx+1}/3 allocated (~500MB)")
          
          print("âš¡ Starting intensive CPU work on all cores...")
          start_time = time.time()
          
          # CPU-intensive function for multiprocessing
          def cpu_intensive_work(task_id):
              result = 0
              # Heavy computation: 100M iterations per task
              for i in range(100000000):
                  result += (i * i * i) % 1000000
              return result
          
          # Spawn processes on all CPU cores
          with Pool(os.cpu_count()) as pool:
              results = pool.map(cpu_intensive_work, range(os.cpu_count()))
          
          # Also compute on the memory arrays while holding them
          print("ğŸ’¾ Computing on large arrays...")
          total_result = sum(results)
          for arr in huge_arrays:
              result = sum(arr[i] * (i % 10) for i in range(0, len(arr), 50000))
              total_result += result
          
          elapsed = time.time() - start_time
          print(f"âœ… Computation complete ({elapsed:.1f}s)")
          print(f"   Total result: {total_result}")
          
          # CRITICAL: Mark WHILE memory is still allocated in this process
          print("ğŸ“ Marking heavy load peak (memory still allocated)...")
          mark_step("Heavy Load Peak")
          
          # Now release memory
          print("ğŸ’¾ Releasing memory...")
          del huge_arrays
          print("âœ… Heavy workload finished")
          PYTHON_EOF

      # Stop telemetry and generate report
      - name: Stop Telemetry
        if: always()
        uses: tsviz/actions-runner-telemetry@v1
        with:
          mode: stop
          enabled: ${{ env.TELEMETRY_ENABLED }}

      - name: Upload Heavy Workload Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: telemetry-heavy-${{ github.run_id }}
          path: |
            telemetry-report.md
            telemetry-dashboard.html
            telemetry-summary.json
          retention-days: 14
          if-no-files-found: ignore
